       PROCEDURE DIVISION.


       ENTRY-PARA.
           PERFORM MAIN-PARA
           STOP RUN.


<<<<<<< HEAD
       minJumps-PARA.
      * If there's only one element, no jumps are needed
       IF n_minJumps = 1
       END-IF
      * If the first element is 0, it's not possible to move anywhere
       IF arr_minJumps[0] = 0
       END-IF
      * Initialize variables
      * Number of jumps made
       MOVE 0 TO jumps_minJumps
      * The farthest point reachable with the current number of jumps
       MOVE 0 TO currentEnd_minJumps
      * The farthest point reachable with the next jump
       MOVE 0 TO farthest_minJumps
       PERFORM VARYING i_minJumps FROM 0 BY 1 UNTIL NOT (i_minJumps < n_minJumps)
      * Update the farthest point reachable
       COMPUTE TEMP_0 = i_minJumps + 1
       COMPUTE TEMP_1 = arr_minJumps + TEMP_0
       COMPUTE farthest_minJumps = TEMP_1
      * If we've reached the end of the array, return the number of jumps
       IF i_minJumps = currentEnd_minJumps
       ADD 1 TO jumps_minJumps
       MOVE farthest_minJumps TO currentEnd_minJumps
      * If the end of the array is within reach with the current jump
       IF currentEnd_minJumps >= n_minJumps - 1
       END-IF
       END-IF
       END-PERFORM
      * If the loop ends without reaching the last element
=======
       MAIN-PARA.
       MOVE 2 TO a_main
       MOVE 3 TO b_main
       MOVE 0 TO i_main
       MOVE 0 TO n_main
       COMPUTE TEMP_0 = a_main + b_main
       PERFORM UNTIL NOT (i_main < TEMP_0)
       COMPUTE TEMP_1 = n_main + 2
       PERFORM VARYING j_main FROM 0 BY 1 UNTIL NOT (j_main < TEMP_1)
       ADD 1 TO a_main
       ADD 1 TO i_main
       COMPUTE TEMP_1 = n_main + 2
       END-PERFORM
       COMPUTE TEMP_0 = a_main + b_main
       END-PERFORM
>>>>>>> 28b8c928417ac931a4bf3d5a3b0f39cef431571d
       EXIT.

